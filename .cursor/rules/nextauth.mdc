# NextAuth.js Rules

## Authentication Setup

- Use NextAuth.js v4 with App Router
- Implement proper session management
- Use secure session strategies
- Implement proper error handling
- Use environment variables for secrets

## Session Management

- Use JWT strategy for stateless sessions
- Implement proper session callbacks
- Use secure session configuration
- Handle session expiration gracefully
- Implement proper logout functionality

## Authorization Patterns

- Use middleware for route protection
- Implement role-based access control
- Use proper session validation
- Handle authentication errors gracefully
- Implement proper redirect handling

## Example NextAuth Configuration

```typescript
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
```

```typescript
// src/lib/auth.ts
import { NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: '/auth/signin',
    signOut: '/auth/signout',
    error: '/auth/error',
  },
  callbacks: {
    async jwt({ token, user, account }) {
      // Persist the OAuth access_token and or the user id to the token right after signin
      if (account && user) {
        token.accessToken = account.access_token;
        token.userId = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      // Send properties to the client, like an access_token and user id from a provider.
      session.accessToken = token.accessToken;
      session.user.id = token.userId;

      // Fetch additional user data if needed
      if (token.userId) {
        const user = await prisma.user.findUnique({
          where: { id: token.userId },
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            phone: true,
            address: true,
            city: true,
            state: true,
            zipCode: true,
          },
        });

        if (user) {
          session.user = { ...session.user, ...user };
        }
      }

      return session;
    },
    async redirect({ url, baseUrl }) {
      // Allows relative callback URLs
      if (url.startsWith('/')) return `${baseUrl}${url}`;
      // Allows callback URLs on the same origin
      else if (new URL(url).origin === baseUrl) return url;
      return baseUrl;
    },
  },
  providers: [
    // Configure your providers here
  ],
  events: {
    async signIn({ user, account, profile, isNewUser }) {
      if (isNewUser) {
        // Handle new user registration
        console.log('New user signed up:', user.email);
      }
    },
    async signOut({ session, token }) {
      // Handle sign out
      console.log('User signed out');
    },
  },
};
```

## Middleware for Route Protection

```typescript
// src/middleware.ts
import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth(
  function middleware(req) {
    // Add custom middleware logic here
    const token = req.nextauth.token;
    const isAuth = !!token;
    const isAuthPage = req.nextUrl.pathname.startsWith('/auth');
    const isProtectedPage =
      req.nextUrl.pathname.startsWith('/dashboard') ||
      req.nextUrl.pathname.startsWith('/settings') ||
      req.nextUrl.pathname.startsWith('/post-item');

    if (isAuthPage) {
      if (isAuth) {
        return NextResponse.redirect(new URL('/dashboard', req.url));
      }
      return null;
    }

    if (isProtectedPage && !isAuth) {
      return NextResponse.redirect(new URL('/auth/signin', req.url));
    }

    return null;
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token,
    },
  }
);

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/settings/:path*',
    '/post-item/:path*',
    '/auth/:path*',
  ],
};
```

## Custom Hooks for Authentication

```typescript
// src/lib/hooks/useAuth.ts
import { useSession, signIn, signOut } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useCallback } from 'react';

export function useAuth() {
  const { data: session, status, update } = useSession();
  const router = useRouter();

  const login = useCallback(
    async (provider?: string) => {
      try {
        const result = await signIn(provider, {
          callbackUrl: '/dashboard',
          redirect: false,
        });

        if (result?.error) {
          throw new Error(result.error);
        }

        if (result?.url) {
          router.push(result.url);
        }
      } catch (error) {
        console.error('Login error:', error);
        throw error;
      }
    },
    [router]
  );

  const logout = useCallback(async () => {
    try {
      await signOut({
        callbackUrl: '/',
        redirect: false,
      });
      router.push('/');
    } catch (error) {
      console.error('Logout error:', error);
      throw error;
    }
  }, [router]);

  const refreshSession = useCallback(async () => {
    try {
      await update();
    } catch (error) {
      console.error('Session refresh error:', error);
      throw error;
    }
  }, [update]);

  return {
    session,
    status,
    isAuthenticated: !!session,
    isLoading: status === 'loading',
    login,
    logout,
    refreshSession,
  };
}
```

## Protected Route Component

```typescript
// src/components/auth-guard.tsx
'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

interface AuthGuardProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  redirectTo?: string;
}

export function AuthGuard({
  children,
  fallback = <div>Loading...</div>,
  redirectTo = '/auth/signin',
}: AuthGuardProps) {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'loading') return;

    if (!session) {
      router.push(redirectTo);
    }
  }, [session, status, router, redirectTo]);

  if (status === 'loading') {
    return <>{fallback}</>;
  }

  if (!session) {
    return null;
  }

  return <>{children}</>;
}
```

## API Route Protection

```typescript
// src/lib/auth-utils.ts
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { NextRequest, NextResponse } from 'next/server';

export async function getSession() {
  return await getServerSession(authOptions);
}

export async function requireAuth(request: NextRequest) {
  const session = await getSession();

  if (!session) {
    return NextResponse.json(
      { error: 'Authentication required' },
      { status: 401 }
    );
  }

  return session;
}

export async function requireUser(request: NextRequest) {
  const session = await requireAuth(request);

  if (!session.user?.id) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  return session;
}
```

## Example Protected API Route

```typescript
// src/app/api/items/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { requireUser } from '@/lib/auth-utils';
import { ItemsService } from '@/lib/features/items/itemsService';

export async function POST(request: NextRequest) {
  try {
    const session = await requireUser(request);
    const body = await request.json();

    const item = await ItemsService.createItem(body, session.user.id);

    return NextResponse.json(item, { status: 201 });
  } catch (error) {
    if (error instanceof NextResponse) {
      return error;
    }

    console.error('Create item error:', error);
    return NextResponse.json(
      { error: 'Failed to create item' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const session = await requireUser(request);
    const { searchParams } = new URL(request.url);

    const options = {
      userId: searchParams.get('userId') || undefined,
      category: searchParams.get('category') || undefined,
      status: searchParams.get('status') || undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '20'),
    };

    const result = await ItemsService.getItems(options);

    return NextResponse.json(result);
  } catch (error) {
    if (error instanceof NextResponse) {
      return error;
    }

    console.error('Get items error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch items' },
      { status: 500 }
    );
  }
}
```

## Session Types

```typescript
// src/types/next-auth.d.ts
import { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  interface Session {
    accessToken?: string;
    user: {
      id: string;
      phone?: string;
      address?: string;
      city?: string;
      state?: string;
      zipCode?: string;
    } & DefaultSession['user'];
  }

  interface User {
    id: string;
    phone?: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    accessToken?: string;
    userId?: string;
  }
}
```

## Login Component

```typescript
// src/components/login-btn.tsx
'use client';

import { signIn, signOut, useSession } from 'next-auth/react';
import { Button } from '@/components/ui/button';

export function LoginBtn() {
  const { data: session, status } = useSession();

  if (status === 'loading') {
    return <Button disabled>Loading...</Button>;
  }

  if (session) {
    return (
      <div className="flex items-center gap-4">
        <span>Welcome, {session.user.name}</span>
        <Button variant="outline" onClick={() => signOut()}>
          Sign Out
        </Button>
      </div>
    );
  }

  return <Button onClick={() => signIn()}>Sign In</Button>;
}
```

description:
globs:
alwaysApply: true

---
